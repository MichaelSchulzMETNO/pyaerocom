
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{intro\_time\_handling}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \subsection{\texorpdfstring{Handling of CF time in
\emph{Pyaerocom}}{Handling of CF time in Pyaerocom}}\label{handling-of-cf-time-in-pyaerocom}

The
\href{http://aerocom.met.no/pyaerocom/api.html\#module-pyaerocom.modeldata}{ModelData}
class of \emph{Pyaerocom} was introduced in
\href{http://aerocom.met.no/pyaerocom/notebooks.html\#introducing-the-modeldata-class}{this
notebook}.

Here, we want to illustrate one particular feature of \emph{Pyaerocom},
namely the conversion of CF conform numerical time stamps with a defined
unit (i.e. basedate and calendar, see e.g.
\href{http://cfconventions.org/Data/cf-conventions/cf-conventions-1.6/build/cf-conventions.html\#time-coordinate}{here}
for details) into datetime-like objects that can be interpreted by tools
such as \href{https://pandas.pydata.org/}{Pandas}. The easiest way to
work with time stamps in model data is, to simply work on the internal
numerical indices, avoiding the necessity to convert them into actual
datetime objects. However, sometimes (e.g. if we want to extract and
analyse a time-series of global average Aerosol optical densities), we
wish to use third party libraries such as Pandas, which require the
timestamps to be datetime-like objects.

This notebook illustrates how time is handled in the iris module,
particularly in the
\href{http://scitools.org.uk/iris/docs/v1.9.0/html/iris/iris/cube.html\#iris.cube.Cube}{Cube}
class, which is the basic data representation object in the
\emph{Pyaerocom} \texttt{ModelData} class. In particular, it emphazises
some peculiarities that can lead to complications and finally shows, how
\emph{Pyaerocom} circumvents these issues. We shall see, that this does
not only reduce the risk of conversion Errors, bu even results in a
quite significant performance boost when converting from numerical CF
timestamps to \texttt{numpy.datetime64} time stamps.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{k+kn}{import} \PY{n+nn}{warnings}
        \PY{n}{warnings}\PY{o}{.}\PY{n}{filterwarnings}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ignore}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k+kn}{import} \PY{n+nn}{pyaerocom}
\end{Verbatim}


    \subsubsection{Load and plot some example
data}\label{load-and-plot-some-example-data}

Get and load test data file using the new pyaerocom interface (the
underlying datatype of \texttt{ModelData} is \texttt{iris.cube.Cube}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{n}{files} \PY{o}{=} \PY{n}{pyaerocom}\PY{o}{.}\PY{n}{io}\PY{o}{.}\PY{n}{testfiles}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{p}{)}
        
        \PY{n}{fpath\PYZus{}ecmwf} \PY{o}{=} \PY{n}{files}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{models}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ecmwf\PYZus{}osuite}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
        \PY{n}{fpath\PYZus{}aatsr} \PY{o}{=} \PY{n}{files}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{models}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{aatsr\PYZus{}su\PYZus{}v4.3}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{n}{data\PYZus{}ecmwf} \PY{o}{=} \PY{n}{pyaerocom}\PY{o}{.}\PY{n}{ModelData}\PY{p}{(}\PY{n}{fpath\PYZus{}ecmwf}\PY{p}{,} \PY{n}{var\PYZus{}name}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{od550aer}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{model\PYZus{}id}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ECMWF\PYZus{}OSUITE}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n}{data\PYZus{}aatsr} \PY{o}{=} \PY{n}{pyaerocom}\PY{o}{.}\PY{n}{ModelData}\PY{p}{(}\PY{n}{fpath\PYZus{}aatsr}\PY{p}{,} \PY{n}{var\PYZus{}name}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{od550aer}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{model\PYZus{}id}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{AATSR}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Rolling longitudes to -180 -> 180 definition

    \end{Verbatim}

    Note that, if the longitudes are defined on a 0 -\textgreater{} 360
degree grid, they are automatically converted to -180 -\textgreater{}
180 (the case of the ECMWF data).

Now, let's have a quick look and see what is in there.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{n}{fig} \PY{o}{=} \PY{n}{data\PYZus{}ecmwf}\PY{o}{.}\PY{n}{quickplot\PYZus{}map}\PY{p}{(}\PY{p}{)}
        \PY{n}{fig2} \PY{o}{=} \PY{n}{data\PYZus{}aatsr}\PY{o}{.}\PY{n}{quickplot\PYZus{}map}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_6_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_6_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsubsection{Digging into the time representation of iris
Cubes}\label{digging-into-the-time-representation-of-iris-cubes}

The \texttt{ModelData} class is based on the \texttt{iris.Cube} object,
which can be accessed via the \texttt{grid} attribute. In the following,
some features of the \texttt{Cube} class are introduced.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{n}{cube\PYZus{}ecmwf} \PY{o}{=} \PY{n}{data\PYZus{}ecmwf}\PY{o}{.}\PY{n}{grid}
        \PY{n}{cube\PYZus{}aatsr} \PY{o}{=} \PY{n}{data\PYZus{}aatsr}\PY{o}{.}\PY{n}{grid}
\end{Verbatim}


    \paragraph{\texorpdfstring{Peculiarities of time handling when using the
\texttt{Cube}
interface}{Peculiarities of time handling when using the Cube interface}}\label{peculiarities-of-time-handling-when-using-the-cube-interface}

Starting with how time is handled. The time is represented as numerical
value relative to a basic date and frequency unit and in the optimum
case, also the specification of a calendar, according to the
\href{http://cfconventions.org/Data/cf-conventions/cf-conventions-1.6/build/cf-conventions.html\#time-coordinate}{NetCDF
CF conventions}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{n}{times\PYZus{}ecmwf} \PY{o}{=} \PY{n}{cube\PYZus{}ecmwf}\PY{o}{.}\PY{n}{coord}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{time}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ECMWF}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{First point:}\PY{l+s+si}{\PYZpc{}s}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{Time unit: }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{Calendar: }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}}\PY{p}{(}\PY{n}{times\PYZus{}ecmwf}\PY{o}{.}\PY{n}{points}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
                                                                       \PY{n}{times\PYZus{}ecmwf}\PY{o}{.}\PY{n}{units}\PY{o}{.}\PY{n}{name}\PY{p}{,} 
                                                                       \PY{n}{times\PYZus{}ecmwf}\PY{o}{.}\PY{n}{units}\PY{o}{.}\PY{n}{calendar}\PY{p}{)}\PY{p}{)}
        \PY{n}{times\PYZus{}aatsr}\PY{o}{=} \PY{n}{cube\PYZus{}aatsr}\PY{o}{.}\PY{n}{coord}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{time}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{AATSR}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{First point:}\PY{l+s+si}{\PYZpc{}s}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{Time unit: }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{Calendar: }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}}\PY{p}{(}\PY{n}{times\PYZus{}aatsr}\PY{o}{.}\PY{n}{points}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} 
                                                                     \PY{n}{times\PYZus{}aatsr}\PY{o}{.}\PY{n}{units}\PY{o}{.}\PY{n}{name}\PY{p}{,} 
                                                                     \PY{n}{times\PYZus{}aatsr}\PY{o}{.}\PY{n}{units}\PY{o}{.}\PY{n}{calendar}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
ECMWF
First point:0.0
Time unit: day since 2018-01-01 00:00:00.00000000 UTC
Calendar: gregorian

AATSR
First point:0.0
Time unit: day since 2008-01-01 00:00:00.00000000 UTC
Calendar: julian


    \end{Verbatim}

    Note that the AATSR data is defined using a Julian calendar. The actual
time objects are instances of the \texttt{DimCoord} class of the iris
package.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n+nb}{type}\PY{p}{(}\PY{n}{times\PYZus{}ecmwf}\PY{p}{)}\PY{p}{,} \PY{n+nb}{type}\PY{p}{(}\PY{n}{times\PYZus{}aatsr}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
<class 'iris.coords.DimCoord'> <class 'iris.coords.DimCoord'>

    \end{Verbatim}

    Now, if we want to convert these numerically represented time stamps
into datetime-like objects that, for instance, the \texttt{pandas}
library understands, we have several options. The first one, which is
the most obvious one, is using the provided iris interface which does
the conversion for us, that is, using the \texttt{cell(index)} method
(with the corresponding \texttt{index}) of the \texttt{DimCoord} class
in combination with the \texttt{cells()} iterator method. However, as we
shall see below, this is not only the slowest solution but it is also
prone to errors in case the calendar is not standard (e.g. Julian).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{n}{t0\PYZus{}ecmwf} \PY{o}{=} \PY{n}{times\PYZus{}ecmwf}\PY{o}{.}\PY{n}{cell}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}\PY{o}{.}\PY{n}{point}
        \PY{n}{t0\PYZus{}aatsr} \PY{o}{=} \PY{n}{times\PYZus{}aatsr}\PY{o}{.}\PY{n}{cell}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}\PY{o}{.}\PY{n}{point}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{First time stamp ECMWF }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+s2}{ (data type: }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}}\PY{p}{(}\PY{n}{t0\PYZus{}ecmwf}\PY{p}{,} \PY{n+nb}{type}\PY{p}{(}\PY{n}{t0\PYZus{}ecmwf}\PY{p}{)}\PY{p}{)}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{First time stamp AATSR }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+s2}{ (data type: }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}}\PY{p}{(}\PY{n}{t0\PYZus{}aatsr}\PY{p}{,} \PY{n+nb}{type}\PY{p}{(}\PY{n}{t0\PYZus{}aatsr}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
First time stamp ECMWF 2018-01-01 00:00:00 (data type: <class 'datetime.datetime'>)
First time stamp AATSR 2008-01-01 00:00:00 (data type: <class 'netcdftime.\_netcdftime.DatetimeJulian'>)

    \end{Verbatim}

    As you can see, the \texttt{cell} method returns different datatypes,
dependent on the CF unit convention, that is, a standard Python
\texttt{datetime.datetime} object, if the calendar is Gregorian, and a
\texttt{netcdftime.\_netcdftime.DatetimeJulian} object in case of a
Julian calendar. Problem here is, that the former is understood by
pandas, while the latter is not.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{k+kn}{import} \PY{n+nn}{pandas}
        
        \PY{n}{t0\PYZus{}ecmwf\PYZus{}pandas} \PY{o}{=} \PY{n}{pandas}\PY{o}{.}\PY{n}{Timestamp}\PY{p}{(}\PY{n}{t0\PYZus{}ecmwf}\PY{p}{)}
        \PY{k}{try}\PY{p}{:}
            \PY{n}{t0\PYZus{}aatsr\PYZus{}pandas} \PY{o}{=} \PY{n}{pandas}\PY{o}{.}\PY{n}{Timestamp}\PY{p}{(}\PY{n}{t0\PYZus{}aatsr}\PY{p}{)}
        \PY{k}{except} \PY{n+ne}{TypeError} \PY{k}{as} \PY{n}{e}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{n+nb}{repr}\PY{p}{(}\PY{n}{e}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
TypeError("Cannot convert input [2008-01-01 00:00:00] of type <class 'netcdftime.\_netcdftime.DatetimeJulian'> to Timestamp",)

    \end{Verbatim}

    Nontheless, numpy is easier in that sense, since it understands both
datatypes.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
         
         \PY{n}{t0\PYZus{}ecmwf\PYZus{}np} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{datetime64}\PY{p}{(}\PY{n}{t0\PYZus{}ecmwf}\PY{p}{)}
         \PY{n}{t0\PYZus{}aatsr\PYZus{}np} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{datetime64}\PY{p}{(}\PY{n}{t0\PYZus{}aatsr}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{t0\PYZus{}ecmwf\PYZus{}np}\PY{p}{,} \PY{n}{t0\PYZus{}aatsr\PYZus{}np}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
2018-01-01T00:00:00.000000 2008-01-01T00:00:00.000000

    \end{Verbatim}

    Fair enough, but however, in the end we want to ensure to have a
conversion method ready that handles any calendar, and that is
considerably fast. We just saw, that \texttt{datetime64} works for both
datetime formats that we get when calling the \texttt{cell} method of
the \texttt{DimCoord} object that holds the time stamps. However, keep
in mind, that whenever \texttt{call} is called, it performs a conversion
of the numeric value into either \texttt{datetime.datetime} or, for
non-standard calendars, into a datetime object from the
\href{https://github.com/Unidata/cftime}{cftime} package. So, either
way, when using the \texttt{cell} method we have to iterate over all
indices to convert the numerical values into datetime-like objects. The
latter may be done using the \texttt{cells()} iterator of the
\texttt{DimCoord} class.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n}{times\PYZus{}ecmwf\PYZus{}conv} \PY{o}{=} \PY{p}{[}\PY{n}{t}\PY{o}{.}\PY{n}{point} \PY{k}{for} \PY{n}{t} \PY{o+ow}{in} \PY{n}{times\PYZus{}ecmwf}\PY{o}{.}\PY{n}{cells}\PY{p}{(}\PY{p}{)}\PY{p}{]}
         \PY{n}{times\PYZus{}aatsr\PYZus{}conv} \PY{o}{=} \PY{p}{[}\PY{n}{t}\PY{o}{.}\PY{n}{point} \PY{k}{for} \PY{n}{t} \PY{o+ow}{in} \PY{n}{times\PYZus{}aatsr}\PY{o}{.}\PY{n}{cells}\PY{p}{(}\PY{p}{)}\PY{p}{]}
         \PY{c+c1}{\PYZsh{}display first two}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+si}{\PYZpc{}s}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+si}{\PYZpc{}s}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}}\PY{p}{(}\PY{n}{times\PYZus{}ecmwf\PYZus{}conv}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{times\PYZus{}aatsr\PYZus{}conv}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{W}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
[datetime.datetime(2018, 1, 1, 0, 0), datetime.datetime(2018, 1, 2, 0, 0)]

[netcdftime.\_netcdftime.DatetimeJulian(2008, 1, 1, 0, 0, 0, 0, -1, 1), netcdftime.\_netcdftime.DatetimeJulian(2008, 1, 2, 0, 0, 0, 0, -1, 1)]
W

    \end{Verbatim}

    This worked, but however, is it fast?

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{timeit} 
         [t.point for t in times\PYZus{}ecmwf.cells()]
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
117 ms ± 3.24 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{timeit}
         [t.point for t in times\PYZus{}aatsr.cells()]
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
102 ms ± 2.01 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

    \end{Verbatim}

    The answer is: No, it is not fast, and furthermore, the latter datatype
will not be accepted by pandas as a valid datetime object. We can,
however, convert the datapoints to numpy datetime64 objects during the
conversion (if we want).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{timeit} 
         [np.datetime64(t.point) for t in times\PYZus{}ecmwf.cells()]
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
133 ms ± 7.15 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{timeit}
         [np.datetime64(t.point) for t in times\PYZus{}aatsr.cells()]
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
109 ms ± 4.8 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

    \end{Verbatim}

    That looks okay, since it does not lead to a notable decrease in the
performance and ensures, that pandas will understand the datatype.
However, about 100ms for conversion of 365 dates is rather slow.

\paragraph{Other options to convert
timestamps}\label{other-options-to-convert-timestamps}

Above we saw how we can convert the numerical timestamps into an array
of numpy \texttt{datetime64} objects (which is what we want in the end).
As we shall see below, the conversion can be significantly accelarated
if we do not use the iris interface provided by the \texttt{cell(index)}
method and the \texttt{cells()} iterator, but rather directly use the
underlying \texttt{cftime} library (that iris uses).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{timeit}
         [np.datetime64(t) for t in times\PYZus{}ecmwf.units.num2date(times\PYZus{}ecmwf.points)]
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
1.66 ms ± 42.8 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

    \end{Verbatim}

    This is quite an improvement. But if we dig a little deeper, we can
boost this even more, as we shall see in the following. Basically, what
it does is accessing the base date that is encrypted in the unit, i.e.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{times\PYZus{}ecmwf}\PY{o}{.}\PY{n}{units}\PY{o}{.}\PY{n}{name}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
day since 2018-01-01 00:00:00.00000000 UTC

    \end{Verbatim}

    and based on this base date, and the encrypted temporal resolution (here
\emph{day}) uses the
\href{https://docs.scipy.org/doc/numpy-1.14.0/reference/arrays.datetime.html}{pure
numpy datetime functionality} to convert the stuff. For this, we have to
test if the first sub string (here \emph{day}) is valid according to the
CF standard, which we do using some features from the \texttt{netCDF4}
package and by defining a function, that translates the numerical
timestamps into \texttt{datetime64} objects based on the information
encoded in the units string(e.g. \emph{day since 2018-01-01
00:00:00.00000000 UTC}) and the corresponding calendar (e.g.
"gregorian").

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{k+kn}{from} \PY{n+nn}{cf\PYZus{}units} \PY{k}{import} \PY{n}{Unit}
         \PY{k+kn}{from} \PY{n+nn}{datetime} \PY{k}{import} \PY{n}{MINYEAR}\PY{p}{,} \PY{n}{datetime}
         \PY{k+kn}{from} \PY{n+nn}{numpy} \PY{k}{import} \PY{n}{asarray}\PY{p}{,} \PY{n}{datetime64}
         \PY{k+kn}{from} \PY{n+nn}{netCDF4} \PY{k}{import} \PY{p}{(}\PY{n}{microsec\PYZus{}units}\PY{p}{,} \PY{n}{millisec\PYZus{}units}\PY{p}{,} \PY{n}{sec\PYZus{}units}\PY{p}{,} \PY{n}{min\PYZus{}units}\PY{p}{,}
                             \PY{n}{hr\PYZus{}units}\PY{p}{,} \PY{n}{day\PYZus{}units}\PY{p}{)}
         \PY{k+kn}{from} \PY{n+nn}{netCDF4}\PY{n+nn}{.}\PY{n+nn}{\PYZus{}netCDF4} \PY{k}{import} \PY{n}{\PYZus{}dateparse}
         \PY{c+c1}{\PYZsh{} Start of the gregorian calendar}
         \PY{c+c1}{\PYZsh{} adapted from here: https://github.com/Unidata/cftime/blob/master/cftime/\PYZus{}cftime.pyx   }
         \PY{n}{GREGORIAN\PYZus{}BASE} \PY{o}{=} \PY{n}{datetime}\PY{p}{(}\PY{l+m+mi}{1582}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{15}\PY{p}{)}
         
         \PY{k}{def} \PY{n+nf}{cftime\PYZus{}to\PYZus{}datetime64}\PY{p}{(}\PY{n}{timesnum}\PY{p}{,} \PY{n}{cfunit}\PY{p}{,} \PY{n}{calendar}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}Convert numerical timestamps with epoch to numpy datetime64}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    This method was designed to enhance the performance of datetime conversions}
         \PY{l+s+sd}{    and is based on the corresponding information provided in the cftime }
         \PY{l+s+sd}{    package (`see here \PYZlt{}https://github.com/Unidata/cftime/blob/master/cftime/}
         \PY{l+s+sd}{    \PYZus{}cftime.pyx\PYZgt{}`\PYZus{}\PYZus{}). Particularly, this object does, what the :func:`num2date` }
         \PY{l+s+sd}{    therein does, but faster, in case the time stamps are not defined on a non}
         \PY{l+s+sd}{    standard calendar.}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    Parameters}
         \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
         \PY{l+s+sd}{    timesnum : :obj:`list` or :obj:`ndarray`}
         \PY{l+s+sd}{        array containing numerical time stamps (relative to basedate of }
         \PY{l+s+sd}{        ``cfunit``). Can also be a single number.}
         \PY{l+s+sd}{    cfunit : :obj:`str` or :obj:`Unit`}
         \PY{l+s+sd}{        CF unit string (e.g. day since 2018\PYZhy{}01\PYZhy{}01 00:00:00.00000000 UTC) or}
         \PY{l+s+sd}{        unit}
         \PY{l+s+sd}{    calendar : :obj:`str`, optional}
         \PY{l+s+sd}{        string specifying calendar (only required if ``cfunit`` is of type}
         \PY{l+s+sd}{        ``str``).}
         \PY{l+s+sd}{        }
         \PY{l+s+sd}{    Returns}
         \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
         \PY{l+s+sd}{    ndarray}
         \PY{l+s+sd}{        numpy array containing timestamps as datetime64 objects}
         \PY{l+s+sd}{        }
         \PY{l+s+sd}{    Raises}
         \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
         \PY{l+s+sd}{    ValueError}
         \PY{l+s+sd}{        if cfunit is ``str`` and calendar is not provided or invalid, or if }
         \PY{l+s+sd}{        the cfunit string is invalid}
         \PY{l+s+sd}{        }
         \PY{l+s+sd}{    Example}
         \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
         \PY{l+s+sd}{    }
         \PY{l+s+sd}{    \PYZgt{}\PYZgt{}\PYZgt{} cfunit\PYZus{}str = \PYZsq{}day since 2018\PYZhy{}01\PYZhy{}01 00:00:00.00000000 UTC\PYZsq{}}
         \PY{l+s+sd}{    \PYZgt{}\PYZgt{}\PYZgt{} cftime\PYZus{}to\PYZus{}datetime64(10, cfunit\PYZus{}str, \PYZdq{}gregorian\PYZdq{})}
         \PY{l+s+sd}{    array([\PYZsq{}2018\PYZhy{}01\PYZhy{}11T00:00:00.000000\PYZsq{}], dtype=\PYZsq{}datetime64[us]\PYZsq{})}
         \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
             \PY{k}{try}\PY{p}{:}
                 \PY{n+nb}{len}\PY{p}{(}\PY{n}{timesnum}\PY{p}{)}
             \PY{k}{except}\PY{p}{:}
                 \PY{n}{timesnum} \PY{o}{=} \PY{p}{[}\PY{n}{timesnum}\PY{p}{]}
             \PY{k}{if} \PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{cfunit}\PY{p}{,} \PY{n+nb}{str}\PY{p}{)}\PY{p}{:}
                 \PY{k}{if} \PY{n}{calendar} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
                     \PY{k}{raise} \PY{n+ne}{ValueError}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Require specification of calendar for }\PY{l+s+s2}{\PYZdq{}}
                                      \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{conversion into datetime64 objects}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
                 \PY{n}{cfunit} \PY{o}{=} \PY{n}{Unit}\PY{p}{(}\PY{n}{cfunit}\PY{p}{,} \PY{n}{calendar}\PY{p}{)} \PY{c+c1}{\PYZsh{}raises Error if calendar is invalid}
             \PY{k}{if} \PY{o+ow}{not} \PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{cfunit}\PY{p}{,} \PY{n}{Unit}\PY{p}{)}\PY{p}{:}
                 \PY{k}{raise} \PY{n+ne}{ValueError}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Please provide cfunit either as instance of class }\PY{l+s+s2}{\PYZdq{}}
                                  \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cf\PYZus{}units.Unit or as a string}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
             \PY{n}{cfu\PYZus{}str}\PY{p}{,} \PY{n}{calendar} \PY{o}{=} \PY{n}{cfunit}\PY{o}{.}\PY{n}{name}\PY{p}{,} \PY{n}{cfunit}\PY{o}{.}\PY{n}{calendar}
             \PY{n}{basedate} \PY{o}{=} \PY{n}{\PYZus{}dateparse}\PY{p}{(}\PY{n}{cfu\PYZus{}str}\PY{p}{)}
             \PY{n}{cfu\PYZus{}str} \PY{o}{=} \PY{n}{cfunit}\PY{o}{.}\PY{n}{name}
             \PY{n}{basedate} \PY{o}{=} \PY{n}{\PYZus{}dateparse}\PY{p}{(}\PY{n}{cfu\PYZus{}str}\PY{p}{)}  
             \PY{k}{if} \PY{p}{(}\PY{p}{(}\PY{n}{calendar} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{proleptic\PYZus{}gregorian}\PY{l+s+s1}{\PYZsq{}} \PY{o+ow}{and} \PY{n}{basedate}\PY{o}{.}\PY{n}{year} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{n}{MINYEAR}\PY{p}{)} \PY{o+ow}{or} 
                 \PY{p}{(}\PY{n}{calendar} \PY{o+ow}{in} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{gregorian}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{standard}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o+ow}{and} \PY{n}{basedate} \PY{o}{\PYZgt{}} \PY{n}{GREGORIAN\PYZus{}BASE}\PY{p}{)}\PY{p}{)}\PY{p}{:}
                 \PY{n}{cfu\PYZus{}str} \PY{o}{=} \PY{n}{cfunit}\PY{o}{.}\PY{n}{name}
                 \PY{n}{res} \PY{o}{=} \PY{n}{cfu\PYZus{}str}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{lower}\PY{p}{(}\PY{p}{)}
                 \PY{k}{if} \PY{n}{res} \PY{o+ow}{in} \PY{n}{microsec\PYZus{}units}\PY{p}{:}
                     \PY{n}{tstr} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{us}\PY{l+s+s2}{\PYZdq{}}
                 \PY{k}{elif} \PY{n}{res} \PY{o+ow}{in} \PY{n}{millisec\PYZus{}units}\PY{p}{:}
                     \PY{n}{tstr} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ms}\PY{l+s+s2}{\PYZdq{}}
                 \PY{k}{elif} \PY{n}{res} \PY{o+ow}{in} \PY{n}{sec\PYZus{}units}\PY{p}{:}
                     \PY{n}{tstr} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{s}\PY{l+s+s2}{\PYZdq{}}
                 \PY{k}{elif} \PY{n}{res} \PY{o+ow}{in} \PY{n}{min\PYZus{}units}\PY{p}{:}
                     \PY{n}{tstr} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{m}\PY{l+s+s2}{\PYZdq{}}
                 \PY{k}{elif} \PY{n}{res} \PY{o+ow}{in} \PY{n}{hr\PYZus{}units}\PY{p}{:}
                     \PY{n}{tstr} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{h}\PY{l+s+s2}{\PYZdq{}}
                 \PY{k}{elif} \PY{n}{res} \PY{o+ow}{in} \PY{n}{day\PYZus{}units}\PY{p}{:}
                     \PY{n}{tstr} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{D}\PY{l+s+s2}{\PYZdq{}}
                 \PY{k}{else}\PY{p}{:}
                     \PY{k}{raise} \PY{n+ne}{ValueError}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{unsupported time units}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
                 
                 \PY{n}{basedate} \PY{o}{=} \PY{n}{datetime64}\PY{p}{(}\PY{n}{basedate}\PY{p}{)}
                 \PY{k}{return} \PY{n}{basedate} \PY{o}{+} \PY{n}{asarray}\PY{p}{(}\PY{n}{timesnum}\PY{p}{,} \PY{n}{dtype}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{timedelta64[}\PY{l+s+si}{\PYZpc{}s}\PY{l+s+s2}{]}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}}\PY{k}{tstr})
             \PY{k}{else}\PY{p}{:}
                 \PY{k}{return} \PY{n}{asarray}\PY{p}{(}\PY{p}{[}\PY{n}{datetime64}\PY{p}{(}\PY{n}{t}\PY{p}{)} \PY{k}{for} \PY{n}{t} \PY{o+ow}{in} \PY{n}{cfunit}\PY{o}{.}\PY{n}{num2date}\PY{p}{(}\PY{n}{timesnum}\PY{p}{)}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    Now let's see how this one performs.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{timeit}
         cftime\PYZus{}to\PYZus{}datetime64(times\PYZus{}ecmwf.points, times\PYZus{}ecmwf.units)
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
58.7 µs ± 511 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)

    \end{Verbatim}

    Actually, due to this significant increase in performance for standard
calendars (compared to the methods used in netCDF4), the above method
was implemented in the pyaerocom package
(\href{aerocom.met.no/pyaerocom/api.html\#pyaerocom.helpers.cftime_to_datetime64}{see
here}).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{k+kn}{from} \PY{n+nn}{pyaerocom}\PY{n+nn}{.}\PY{n+nn}{helpers} \PY{k}{import} \PY{n}{cftime\PYZus{}to\PYZus{}datetime64} \PY{k}{as} \PY{n}{pyaerocom\PYZus{}tconversion}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{timeit}
         pyaerocom\PYZus{}tconversion(times\PYZus{}ecmwf.points, times\PYZus{}ecmwf.units)
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
61.4 µs ± 597 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)

    \end{Verbatim}

    For the AATSR data, the method is slower, since here, the slower
\texttt{num2date} method is used.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{timeit}
         pyaerocom\PYZus{}tconversion(times\PYZus{}aatsr.points, times\PYZus{}aatsr.units)
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
1.9 ms ± 112 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

    \end{Verbatim}

    Now this is an improvement. Starting with around 100ms when using the
iris interface (i.e. iterating over \texttt{cells} of the
\texttt{DimCoord}), for conversion of 365 time stamps, we ended up with
the order of 10 microseconds. And at the same time the new method
ensures that we have them in a format that also pandas understands.

The method is also the standard conversion method in the
\texttt{ModelData.time\_stamps()} method:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{timeit}
         data\PYZus{}ecmwf.time\PYZus{}stamps()
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
88.4 µs ± 7.68 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{timeit}
         data\PYZus{}aatsr.time\PYZus{}stamps()
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
1.92 ms ± 80.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

    \end{Verbatim}


    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
